/**
 * üîê Script de Migration - Chiffrement des Donn√©es Bancaires
 *
 * Ce script chiffre tous les IBAN/BIC existants dans la base de donn√©es
 * Utilise le service de chiffrement AES-256-GCM
 */

import 'dotenv/config'
import { PrismaClient } from '@prisma/client'
import { encrypt, decrypt, validateIban, validateBic } from '@/lib/encryption-service'

const prisma = new PrismaClient()

const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
}

function log(message: string, color: string = colors.reset) {
  console.log(`${color}${message}${colors.reset}`)
}

async function encryptBankingData() {
  try {
    log('\n' + '‚ïê'.repeat(70), colors.bright)
    log('üîê CHIFFREMENT DES DONN√âES BANCAIRES - LAIA Platform', colors.bright + colors.cyan)
    log('‚ïê'.repeat(70) + '\n', colors.bright)

    // V√©rifier que ENCRYPTION_KEY est configur√©e
    if (!process.env.ENCRYPTION_KEY) {
      log('‚ùå ERREUR : ENCRYPTION_KEY n\'est pas configur√©e', colors.red)
      log('\nüí° Ex√©cutez d\'abord : npx tsx scripts/security/secure-production.ts', colors.yellow)
      process.exit(1)
    }

    log('‚úÖ ENCRYPTION_KEY configur√©e', colors.green)

    // R√©cup√©rer toutes les organisations avec des donn√©es bancaires
    const organizations = await prisma.organization.findMany({
      where: {
        OR: [
          { sepaIban: { not: null } },
          { sepaBic: { not: null } },
        ]
      },
      select: {
        id: true,
        name: true,
        sepaIban: true,
        sepaBic: true,
        sepaAccountHolder: true,
      }
    })

    log(`\nüìä ${organizations.length} organisations avec donn√©es bancaires trouv√©es\n`, colors.blue)

    if (organizations.length === 0) {
      log('‚úÖ Aucune donn√©e bancaire √† chiffrer', colors.green)
      return
    }

    let encryptedCount = 0
    let skippedCount = 0
    let errorCount = 0

    for (const org of organizations) {
      log(`\nüìã Organisation : ${org.name}`, colors.cyan)

      try {
        const updates: any = {}

        // Chiffrer sepaIban
        if (org.sepaIban) {
          try {
            decrypt(org.sepaIban)
            log(`  ‚è≠Ô∏è  SEPA IBAN d√©j√† chiffr√©`, colors.yellow)
            skippedCount++
          } catch {
            const cleanIban = org.sepaIban.replace(/\s/g, '').toUpperCase()
            if (validateIban(cleanIban)) {
              const encryptedIban = encrypt(cleanIban)
              updates.sepaIban = encryptedIban
              const testDecrypt = decrypt(encryptedIban)
              if (testDecrypt === cleanIban) {
                log(`  ‚úÖ SEPA IBAN chiffr√© et v√©rifi√©`, colors.green)
              } else {
                log(`  ‚ùå ERREUR : V√©rification du chiffrement SEPA IBAN √©chou√©e`, colors.red)
                errorCount++
                continue
              }
            } else {
              log(`  ‚ö†Ô∏è  SEPA IBAN invalide, ignor√©`, colors.yellow)
              skippedCount++
            }
          }
        }

        // Chiffrer sepaBic
        if (org.sepaBic) {
          try {
            decrypt(org.sepaBic)
            log(`  ‚è≠Ô∏è  SEPA BIC d√©j√† chiffr√©`, colors.yellow)
            skippedCount++
          } catch {
            const cleanBic = org.sepaBic.replace(/\s/g, '').toUpperCase()
            if (validateBic(cleanBic)) {
              const encryptedBic = encrypt(cleanBic)
              updates.sepaBic = encryptedBic
              const testDecrypt = decrypt(encryptedBic)
              if (testDecrypt === cleanBic) {
                log(`  ‚úÖ SEPA BIC chiffr√© et v√©rifi√©`, colors.green)
              } else {
                log(`  ‚ùå ERREUR : V√©rification du chiffrement SEPA BIC √©chou√©e`, colors.red)
                errorCount++
                continue
              }
            } else {
              log(`  ‚ö†Ô∏è  SEPA BIC invalide, ignor√©`, colors.yellow)
              skippedCount++
            }
          }
        }


        // Mettre √† jour l'organisation si des donn√©es ont √©t√© chiffr√©es
        if (Object.keys(updates).length > 0) {
          await prisma.organization.update({
            where: { id: org.id },
            data: updates
          })

          encryptedCount++
          log(`  üíæ Organisation mise √† jour`, colors.green)
        }

      } catch (error) {
        log(`  ‚ùå ERREUR lors du chiffrement : ${error}`, colors.red)
        errorCount++
      }
    }

    // Rapport final
    log('\n' + '‚ïê'.repeat(70), colors.bright)
    log('üìä RAPPORT DE CHIFFREMENT', colors.bright + colors.cyan)
    log('‚ïê'.repeat(70), colors.bright)

    log(`\n‚úÖ Organisations chiffr√©es : ${encryptedCount}`, colors.green)
    log(`‚è≠Ô∏è  D√©j√† chiffr√©es (ignor√©es) : ${skippedCount}`, colors.yellow)
    if (errorCount > 0) {
      log(`‚ùå Erreurs : ${errorCount}`, colors.red)
    }

    if (errorCount === 0) {
      log('\nüéâ Chiffrement termin√© avec succ√®s !', colors.green)
      log('\n‚ö†Ô∏è  IMPORTANT : Sauvegardez ENCRYPTION_KEY dans un endroit s√ªr', colors.yellow)
      log('   Sans cette cl√©, les donn√©es bancaires seront D√âFINITIVEMENT PERDUES', colors.yellow)
    } else {
      log('\n‚ö†Ô∏è  Chiffrement termin√© avec des erreurs. V√©rifiez les logs ci-dessus.', colors.yellow)
    }

  } catch (error) {
    log('\n‚ùå ERREUR CRITIQUE :', colors.red)
    console.error(error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

async function testEncryption() {
  log('\nüß™ Test du service de chiffrement...', colors.cyan)

  try {
    const testData = {
      iban: 'FR7630006000011234567890189',
      bic: 'BNPAFRPPXXX',
    }

    log(`\nDonn√©es de test :`, colors.blue)
    log(`  IBAN : ${testData.iban}`, colors.blue)
    log(`  BIC  : ${testData.bic}`, colors.blue)

    // Test IBAN
    const encryptedIban = encrypt(testData.iban)
    const decryptedIban = decrypt(encryptedIban)

    log(`\n‚úÖ IBAN chiffr√© : ${encryptedIban.substring(0, 30)}...`, colors.green)
    log(`‚úÖ IBAN d√©chiffr√© : ${decryptedIban}`, colors.green)

    if (decryptedIban === testData.iban) {
      log(`‚úÖ Test IBAN r√©ussi`, colors.green)
    } else {
      log(`‚ùå Test IBAN √©chou√©`, colors.red)
      process.exit(1)
    }

    // Test BIC
    const encryptedBic = encrypt(testData.bic)
    const decryptedBic = decrypt(encryptedBic)

    log(`\n‚úÖ BIC chiffr√© : ${encryptedBic.substring(0, 30)}...`, colors.green)
    log(`‚úÖ BIC d√©chiffr√© : ${decryptedBic}`, colors.green)

    if (decryptedBic === testData.bic) {
      log(`‚úÖ Test BIC r√©ussi`, colors.green)
    } else {
      log(`‚ùå Test BIC √©chou√©`, colors.red)
      process.exit(1)
    }

    log(`\nüéâ Tous les tests r√©ussis !`, colors.green)

  } catch (error) {
    log('\n‚ùå Erreur lors du test de chiffrement :', colors.red)
    console.error(error)
    process.exit(1)
  }
}

async function main() {
  const args = process.argv.slice(2)

  if (args.includes('--test')) {
    // Mode test
    await testEncryption()
  } else {
    // Mode normal - chiffrer les donn√©es
    await encryptBankingData()
  }
}

main()

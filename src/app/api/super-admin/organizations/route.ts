import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import { verifyToken } from '@/lib/auth'
import { prisma } from '@/lib/prisma'
import { seedOrganization } from '@/lib/seed-organization'
import { generateOrganizationTemplate } from '@/lib/template-generator'
import { createStripeCustomer } from '@/lib/stripe-service'
import { encrypt, validateIban, validateBic } from '@/lib/encryption-service'
import bcrypt from 'bcryptjs'
import { getAllOrganizations } from '@/lib/tenant-service'
import { getFeaturesForPlan } from '@/lib/features'
import { serializeOrganizationAddons, getAddonById, calculateRecurringAddons, calculateOneTimeAddons } from '@/lib/addons'
import type { OrganizationAddons, AddonPurchaseHistory } from '@/lib/addons'
import { OrgPlan } from '@prisma/client'
import { generateInvoiceNumber, getCurrentBillingPeriod, getNextBillingDate } from '@/lib/subscription-billing'
import { sendInvoiceEmail } from '@/lib/email-service'

export async function GET() {
  try {
    // V√©rifier l'authentification
    const cookieStore = await cookies()
    const token = cookieStore.get('auth-token')?.value

    if (!token) {
      return NextResponse.json({ error: 'Non authentifi√©' }, { status: 401 })
    }

    const decoded = verifyToken(token)
    if (!decoded || !decoded.userId) {
      return NextResponse.json({ error: 'Token invalide' }, { status: 401 })
    }

    // V√©rifier que l'utilisateur est SUPER_ADMIN
    const user = await prisma.user.findFirst({
      where: { id: decoded.userId },
      select: { id: true, name: true, email: true, role: true }
    })

    if (!user || user.role !== 'SUPER_ADMIN') {
      return NextResponse.json({ error: 'Acc√®s refus√©' }, { status: 403 })
    }

    // R√©cup√©rer toutes les organisations
    const organizations = await getAllOrganizations()

    // Statistiques globales
    const totalUsers = await prisma.user.count()
    const totalReservations = await prisma.reservation.count()
    const totalServices = await prisma.service.count()

    // Enrichir chaque organisation avec les statistiques utilisateurs
    const organizationsWithUserStats = await Promise.all(
      organizations.map(async (org) => {
        // R√©cup√©rer tous les utilisateurs de cette organisation avec leur r√¥le
        const users = await prisma.user.findMany({
          where: { organizationId: org.id },
          select: {
            id: true,
            name: true,
            email: true,
            phone: true,
            role: true,
            createdAt: true,
            lastLoginAt: true,
            _count: {
              select: {
                reservations: true
              }
            }
          },
          orderBy: { createdAt: 'desc' }
        })

        // S√©parer les clients des membres de l'√©quipe (staff)
        const clients = users.filter(u => u.role === 'CLIENT')
        const staffMembers = users.filter(u => u.role !== 'CLIENT')

        // Compter les utilisateurs par r√¥le
        const usersByRole = users.reduce((acc, user) => {
          acc[user.role] = (acc[user.role] || 0) + 1
          return acc
        }, {} as Record<string, number>)

        // Mapper les r√¥les vers des labels fran√ßais pour l'√©quipe
        const roleLabels: Record<string, string> = {
          'ORG_OWNER': 'Propri√©taire',
          'ORG_ADMIN': 'Administrateur',
          'LOCATION_MANAGER': 'Responsable d\'√©tablissement',
          'STAFF': 'Praticien(ne)',
          'EMPLOYEE': 'Employ√©(e)',
          'RECEPTIONIST': 'R√©ceptionniste',
          'ACCOUNTANT': 'Comptable',
          'SUPER_ADMIN': 'Super Admin LAIA'
        }

        // Statistiques d'activit√© pour cette organisation
        const [
          totalOrgReservations,
          totalOrgServices,
          activeOrgServices,
          totalOrgProducts
        ] = await Promise.all([
          prisma.reservation.count({
            where: { user: { organizationId: org.id } }
          }),
          prisma.service.count({
            where: { organizationId: org.id }
          }),
          prisma.service.count({
            where: { organizationId: org.id, active: true }
          }),
          prisma.product.count({
            where: { organizationId: org.id }
          })
        ])

        return {
          ...org,
          userStats: {
            total: users.length,
            byRole: usersByRole,
            totalClients: clients.length,
            totalStaff: staffMembers.length
          },
          // üë• √âQUIPE DE L'INSTITUT (Staff accounts)
          staffAccounts: staffMembers.map(staff => ({
            id: staff.id,
            name: staff.name,
            email: staff.email,
            phone: staff.phone,
            role: staff.role,
            roleLabel: roleLabels[staff.role] || staff.role,
            createdAt: staff.createdAt,
            lastLogin: staff.lastLogin
          })),
          // üë§ CLIENTS DE L'INSTITUT
          topClients: clients
            .sort((a, b) => b._count.reservations - a._count.reservations)
            .slice(0, 5)
            .map(client => ({
              id: client.id,
              name: client.name,
              email: client.email,
              reservationCount: client._count.reservations,
              createdAt: client.createdAt,
              lastLogin: client.lastLogin
            })),
          activityStats: {
            reservations: totalOrgReservations,
            services: totalOrgServices,
            activeServices: activeOrgServices,
            products: totalOrgProducts
          }
        }
      })
    )

    // Calculer les statistiques globales des comptes staff
    const globalStaffCount = organizationsWithUserStats.reduce((sum, org) => sum + org.userStats.totalStaff, 0)
    const globalClientCount = organizationsWithUserStats.reduce((sum, org) => sum + org.userStats.totalClients, 0)

    // Compter les r√¥les staff globalement
    const globalStaffByRole = organizationsWithUserStats.reduce((acc, org) => {
      Object.entries(org.userStats.byRole).forEach(([role, count]) => {
        if (role !== 'CLIENT') {
          acc[role] = (acc[role] || 0) + count
        }
      })
      return acc
    }, {} as Record<string, number>)

    return NextResponse.json({
      user,
      organizations: organizationsWithUserStats,
      stats: {
        totalUsers,
        totalReservations,
        totalServices,
        totalOrganizations: organizations.length,
        activeOrganizations: organizations.filter(o => o.status === 'ACTIVE' || o.status === 'TRIAL').length,
        // üìä Statistiques des comptes
        totalClients: globalClientCount,
        totalStaff: globalStaffCount,
        staffByRole: globalStaffByRole
      }
    })

  } catch (error) {
    console.error('Erreur r√©cup√©ration organisations:', error)
    return NextResponse.json(
      { error: 'Erreur lors de la r√©cup√©ration' },
      { status: 500 }
    )
  }
}

export async function POST(request: Request) {
  try {
    // V√©rifier l'authentification
    const cookieStore = await cookies()
    const token = cookieStore.get('auth-token')?.value

    if (!token) {
      return NextResponse.json({ error: 'Non authentifi√©' }, { status: 401 })
    }

    const decoded = verifyToken(token)
    if (!decoded) {
      return NextResponse.json({ error: 'Token invalide' }, { status: 401 })
    }

    // V√©rifier que l'utilisateur est SUPER_ADMIN
    const user = await prisma.user.findFirst({
      where: { id: decoded.userId },
      select: { role: true }
    })

    if (!user || user.role !== 'SUPER_ADMIN') {
      return NextResponse.json({ error: 'Acc√®s refus√©' }, { status: 403 })
    }

    // R√©cup√©rer les donn√©es du formulaire
    const data = await request.json()

    // V√©rifier que le slug et subdomain sont uniques
    const existingOrg = await prisma.organization.findFirst({
      where: {
        OR: [
          { slug: data.slug },
          { subdomain: data.subdomain }
        ]
      }
    })

    if (existingOrg) {
      return NextResponse.json(
        { error: 'Le slug ou subdomain existe d√©j√†' },
        { status: 400 }
      )
    }

    // Calculer le montant mensuel selon le plan
    // Prix adapt√©s aux revenus des instituts esth√©tiques
    const planPrices = {
      SOLO: 49,      // 3% du revenu moyen
      DUO: 89,       // 4% du revenu moyen
      TEAM: 149,     // 5% du revenu moyen
      PREMIUM: 249   // <3% du revenu moyen
    }
    const basePlanPrice = planPrices[data.plan as keyof typeof planPrices] || 49

    // Calculer le co√ªt total des add-ons r√©currents
    const selectedAddonsArray: string[] = data.selectedAddons || []
    const recurringAddonsTotal = calculateRecurringAddons(selectedAddonsArray)

    // Montant mensuel total = forfait de base + add-ons r√©currents
    const monthlyAmount = basePlanPrice + recurringAddonsTotal

    // Date de fin d'essai (30 jours)
    const trialEndsAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)

    // Valider et chiffrer les donn√©es SEPA
    let encryptedIban: string | undefined
    let encryptedBic: string | undefined

    if (data.sepaIban && data.sepaBic) {
      // Valider l'IBAN
      if (!validateIban(data.sepaIban)) {
        return NextResponse.json(
          { error: 'IBAN invalide' },
          { status: 400 }
        )
      }

      // Valider le BIC
      if (!validateBic(data.sepaBic)) {
        return NextResponse.json(
          { error: 'BIC invalide' },
          { status: 400 }
        )
      }

      // Chiffrer les donn√©es sensibles
      encryptedIban = encrypt(data.sepaIban)
      encryptedBic = encrypt(data.sepaBic)
    }

    // G√©n√©rer une r√©f√©rence unique de mandat SEPA (RUM)
    const sepaMandateRef = `LAIA-${data.slug.toUpperCase()}-${Date.now()}`

    // Obtenir les features selon le plan choisi
    const planFeatures = getFeaturesForPlan(data.plan as OrgPlan)

    // Traiter les add-ons s√©lectionn√©s
    const selectedAddons: string[] = data.selectedAddons || []
    const addonsHistory: AddonPurchaseHistory[] = []
    const recurringAddons: string[] = []
    const oneTimeAddons: string[] = []

    // Trier les addons par type et cr√©er l'historique
    for (const addonId of selectedAddons) {
      const addon = getAddonById(addonId)
      if (addon) {
        if (addon.type === 'recurring') {
          recurringAddons.push(addonId)
        } else {
          oneTimeAddons.push(addonId)
        }

        addonsHistory.push({
          addonId: addon.id,
          purchaseDate: new Date().toISOString(),
          price: addon.price,
          type: addon.type,
          status: addon.type === 'recurring' ? 'active' : 'completed',
        })
      }
    }

    // Cr√©er l'objet addons √† stocker
    const organizationAddons: OrganizationAddons = {
      recurring: recurringAddons,
      oneTime: oneTimeAddons,
      history: addonsHistory,
    }

    const serializedAddons = serializeOrganizationAddons(organizationAddons)

    // Cr√©er l'organisation avec les informations minimales + facturation + SEPA + addons
    const organization = await prisma.organization.create({
      data: {
        name: data.name,
        slug: data.slug,
        legalName: data.legalName || data.name, // Raison sociale ou nom commercial
        type: 'SINGLE_LOCATION', // Par d√©faut un seul emplacement
        subdomain: data.subdomain,
        domain: null, // Sera configur√© plus tard si besoin
        plan: data.plan,
        status: 'TRIAL', // D√©marrer en p√©riode d'essai
        ownerEmail: data.ownerEmail,
        ownerPhone: data.ownerPhone || null,
        billingEmail: data.billingEmail || data.ownerEmail, // Email de facturation
        billingAddress: data.billingAddress || null, // Adresse de facturation

        // Informations SEPA pour pr√©l√®vement automatique (CHIFFR√âES)
        sepaIban: encryptedIban,
        sepaBic: encryptedBic,
        sepaAccountHolder: data.sepaAccountHolder,
        sepaMandateRef: sepaMandateRef,
        sepaMandateDate: new Date(), // Date de signature du mandat = aujourd'hui
        sepaMandate: data.sepaMandate, // Boolean: mandat accept√©

        // Facturation automatique
        monthlyAmount: monthlyAmount,
        nextBillingDate: trialEndsAt, // Premier pr√©l√®vement = fin de l'essai

        maxLocations: data.plan === 'SOLO' ? 1 : data.plan === 'DUO' ? 1 : data.plan === 'TEAM' ? 3 : 999,
        maxUsers: data.plan === 'SOLO' ? 1 : data.plan === 'DUO' ? 3 : data.plan === 'TEAM' ? 10 : 999,
        maxStorage: data.plan === 'SOLO' ? 5 : data.plan === 'DUO' ? 10 : data.plan === 'TEAM' ? 50 : 999,
        trialEndsAt: trialEndsAt,

        // Features activ√©es selon le forfait
        featureBlog: planFeatures.featureBlog,
        featureProducts: planFeatures.featureProducts,
        featureCRM: planFeatures.featureCRM,
        featureStock: planFeatures.featureStock,
        featureFormations: planFeatures.featureFormations,

        // Add-ons s√©lectionn√©s
        addons: serializedAddons,
      }
    })

    // Cr√©er la configuration de l'organisation (avec valeurs par d√©faut + SIRET)
    await prisma.organizationConfig.create({
      data: {
        organizationId: organization.id,
        siteName: data.name,
        siteTagline: `Institut de Beaut√© √† ${data.city}`,
        email: data.billingEmail || data.ownerEmail,
        phone: data.ownerPhone,
        city: data.city,
        siret: data.siret, // SIRET pour facturation
        // Le reste sera configur√© par l'admin
      }
    })

    // Cr√©er l'emplacement principal
    await prisma.location.create({
      data: {
        organizationId: organization.id,
        name: `${data.name} - ${data.city}`,
        slug: 'principal',
        address: `√Ä configurer - ${data.city}`,
        city: data.city,
        postalCode: '00000', // √Ä d√©finir par l'admin
        isMainLocation: true,
        active: true
      }
    })

    // Cr√©er les param√®tres de paiement
    await prisma.paymentSettings.create({
      data: {
        organizationId: organization.id,
        primaryProvider: 'STRIPE'
      }
    })

    // Cr√©er les param√®tres de r√©servation
    await prisma.bookingSettings.create({
      data: {
        organizationId: organization.id
      }
    })

    // Cr√©er le programme de fid√©lit√© (d√©sactiv√© par d√©faut)
    await prisma.loyaltyProgramSettings.create({
      data: {
        organizationId: organization.id,
        isEnabled: false
      }
    })

    // G√©n√©rer un mot de passe al√©atoire ultra-s√©curis√©
    const generateSecurePassword = () => {
      const length = 16 // Augment√© √† 16 caract√®res
      const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
      const lowercase = 'abcdefghijklmnopqrstuvwxyz'
      const numbers = '0123456789'
      const specialChars = '!@#$%^&*()_+-=[]{}|;:,.<>?'
      const allChars = uppercase + lowercase + numbers + specialChars

      let password = ''

      // Garantir au moins 2 de chaque type pour plus de s√©curit√©
      password += uppercase[Math.floor(Math.random() * uppercase.length)]
      password += uppercase[Math.floor(Math.random() * uppercase.length)]
      password += lowercase[Math.floor(Math.random() * lowercase.length)]
      password += lowercase[Math.floor(Math.random() * lowercase.length)]
      password += numbers[Math.floor(Math.random() * numbers.length)]
      password += numbers[Math.floor(Math.random() * numbers.length)]
      password += specialChars[Math.floor(Math.random() * specialChars.length)]
      password += specialChars[Math.floor(Math.random() * specialChars.length)]

      // Remplir le reste avec des caract√®res al√©atoires
      for (let i = password.length; i < length; i++) {
        password += allChars[Math.floor(Math.random() * allChars.length)]
      }

      // M√©langer de mani√®re plus robuste (Fisher-Yates shuffle)
      const arr = password.split('')
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1))
        ;[arr[i], arr[j]] = [arr[j], arr[i]]
      }

      return arr.join('')
    }

    const generatedPassword = generateSecurePassword()
    const hashedPassword = await bcrypt.hash(generatedPassword, 10)

    // Utiliser l'email du propri√©taire comme identifiant de connexion
    const adminUser = await prisma.user.create({
      data: {
        organizationId: organization.id,
        email: data.ownerEmail,
        password: hashedPassword,
        name: data.ownerEmail.split('@')[0],
        role: 'ORG_ADMIN',
        phone: data.ownerPhone
      }
    })

    // Cr√©er le client Stripe avec mandat SEPA (utiliser les donn√©es NON chiffr√©es)
    if (data.sepaIban && data.sepaBic) {
      try {
        await createStripeCustomer({
          organizationId: organization.id,
          email: data.billingEmail || data.ownerEmail,
          name: data.legalName || data.name,
          iban: data.sepaIban, // Utiliser les donn√©es non chiffr√©es pour Stripe
          bic: data.sepaBic,   // Stripe chiffre ses propres donn√©es
        })
        console.log('‚úÖ Client Stripe cr√©√© avec succ√®s')
      } catch (stripeError) {
        console.error('‚ö†Ô∏è Erreur cr√©ation client Stripe (non bloquant):', stripeError)
        // On ne bloque pas la cr√©ation m√™me si Stripe √©choue
      }
    }

    // G√©n√©rer une facture imm√©diate pour les add-ons ponctuels (Migration Assist√©e, etc.)
    const oneTimeTotal = calculateOneTimeAddons(selectedAddonsArray)

    if (oneTimeTotal > 0) {
      try {
        const invoiceNumber = generateInvoiceNumber()
        const dueDate = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 jours pour payer

        // Cr√©er les lignes de la facture pour les add-ons ponctuels
        const lineItems = oneTimeAddons.map(addonId => {
          const addon = getAddonById(addonId)
          if (!addon) return null

          return {
            description: addon.name,
            quantity: 1,
            unitPrice: addon.price,
            total: addon.price
          }
        }).filter(Boolean)

        // Cr√©er la facture
        const oneTimeInvoice = await prisma.invoice.create({
          data: {
            organizationId: organization.id,
            invoiceNumber,
            amount: oneTimeTotal,
            plan: data.plan,
            status: 'PENDING',
            issueDate: new Date(),
            dueDate,
            description: 'Services ponctuels (aide au d√©marrage)',
            metadata: {
              type: 'one-time-addons',
              lineItems: lineItems
            } as any
          }
        })

        console.log(`‚úÖ Facture ${invoiceNumber} g√©n√©r√©e pour les services ponctuels : ${oneTimeTotal}‚Ç¨`)

        // Envoyer la facture imm√©diatement par email
        try {
          await sendInvoiceEmail({
            organizationName: data.name,
            ownerEmail: data.billingEmail || data.ownerEmail,
            invoiceNumber,
            amount: oneTimeTotal,
            dueDate,
            plan: data.plan,
            lineItems: lineItems as any,
          })
          console.log(`üìß Facture ${invoiceNumber} envoy√©e par email √† ${data.billingEmail || data.ownerEmail}`)
        } catch (emailError) {
          console.error('‚ö†Ô∏è Erreur envoi email facture (non bloquant):', emailError)
          // Ne pas bloquer la cr√©ation si l'email √©choue
        }
      } catch (invoiceError) {
        console.error('‚ö†Ô∏è Erreur g√©n√©ration facture services ponctuels (non bloquant):', invoiceError)
      }
    }

    // G√©n√©rer le template LAIA SKIN INSTITUT pour la nouvelle organisation
    try {
      const templateResult = await generateOrganizationTemplate({
        organizationId: organization.id,
        organizationName: data.name,
        plan: data.plan,
        ownerFirstName: data.ownerFirstName || data.ownerEmail.split('@')[0],
        ownerLastName: data.ownerLastName || '',
        primaryColor: data.primaryColor,
        secondaryColor: data.secondaryColor
      })
      console.log('‚úÖ Template LAIA g√©n√©r√©:', templateResult)
    } catch (templateError) {
      console.error('‚ö†Ô∏è Erreur lors de la g√©n√©ration du template (non bloquant):', templateError)
      // On ne bloque pas la cr√©ation m√™me si le template √©choue
    }

    return NextResponse.json({
      id: organization.id,
      message: 'Organisation cr√©√©e avec succ√®s',
      adminEmail: data.ownerEmail, // Email du propri√©taire utilis√© comme identifiant
      defaultPassword: generatedPassword // Mot de passe ultra-s√©curis√© (16 caract√®res)
    })

  } catch (error) {
    console.error('Erreur cr√©ation organisation:', error)
    return NextResponse.json(
      { error: 'Erreur lors de la cr√©ation' },
      { status: 500 }
    )
  }
}

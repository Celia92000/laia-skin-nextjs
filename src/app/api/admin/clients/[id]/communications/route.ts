import { NextRequest, NextResponse } from 'next/server';
import { isAdminRole } from '@/lib/admin-roles';
import { getPrismaClient } from '@/lib/prisma';
import { getSiteConfig } from '@/lib/config-service';
import jwt from 'jsonwebtoken';

interface CommunicationHistory {
  id: string;
  type: 'whatsapp' | 'email';
  content: string;
  timestamp: Date;
  status: 'sent' | 'delivered' | 'read' | 'failed';
  templateUsed?: string;
  subject?: string;
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const config = await getSiteConfig();
  const siteName = config.siteName || 'Mon Institut';
  const email = config.email || 'contact@institut.fr';
  const primaryColor = config.primaryColor || '#d4b5a0';
  const phone = config.phone || '06 XX XX XX XX';
  const address = config.address || '';
  const city = config.city || '';
  const postalCode = config.postalCode || '';
  const fullAddress = address && city ? `${address}, ${postalCode} ${city}` : 'Votre institut';
  const website = config.customDomain || 'https://votre-institut.fr';
  const ownerName = config.legalRepName?.split(' ')[0] || 'Votre esth√©ticienne';


  const prisma = await getPrismaClient();
  try {
    const { id } = await params;

    // V√©rifier l'authentification
    const authHeader = request.headers.get('authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Non autoris√©' }, { status: 401 });
    }

    const token = authHeader.substring(7);

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
      if (decoded.role !== 'admin' && !isAdminRole(decoded.role)) {
        return NextResponse.json({ error: 'Acc√®s interdit' }, { status: 403 });
      }
    } catch (error) {
      return NextResponse.json({ error: 'Token invalide' }, { status: 401 });
    }

    const clientId = id;

    // R√©cup√©rer l'historique des communications depuis les diff√©rentes tables
    const communications: CommunicationHistory[] = [];

    // 1. R√©cup√©rer les emails envoy√©s
    try {
      const emailHistory = await prisma.emailHistory?.findMany({
        where: {
          userId: clientId
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 50 // Limiter √† 50 derniers
      });

      if (emailHistory) {
        emailHistory.forEach(email => {
          communications.push({
            id: `email-${email.id}`,
            type: 'email',
            content: email.content || email.subject || 'Email envoy√©',
            timestamp: email.createdAt,
            status: email.status as 'sent' | 'delivered' | 'read' | 'failed',
            templateUsed: email.template || 'Email',
            subject: email.subject
          });
        });
      }
    } catch (error) {
      console.log('Table emailHistory non trouv√©e, continuons...');
    }

    // 2. R√©cup√©rer les messages WhatsApp
    try {
      const whatsappHistory = await prisma.whatsAppHistory?.findMany({
        where: {
          userId: clientId
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 50
      });

      if (whatsappHistory) {
        whatsappHistory.forEach(message => {
          communications.push({
            id: `whatsapp-${message.id}`,
            type: 'whatsapp',
            content: message.message,
            timestamp: message.createdAt,
            status: message.status as 'sent' | 'delivered' | 'read' | 'failed',
            templateUsed: 'WhatsApp'
          });
        });
      }
    } catch (error) {
      console.log('Table whatsAppHistory non trouv√©e, continuons...');
    }

    // 3. R√©cup√©rer les emails de r√©servation
    try {
      const reservations = await prisma.reservation.findMany({
        where: {
          userId: clientId,
          OR: [
            { reminderSent: true },
            { reminderSent: true }
          ]
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 20
      });

      reservations.forEach(reservation => {
        if (reservation.reminderSent) {
          communications.push({
            id: `reservation-confirmation-${reservation.id}`,
            type: 'email',
            content: `Email de confirmation de r√©servation pour ${reservation.services}`,
            timestamp: reservation.createdAt,
            status: 'sent',
            templateUsed: 'Confirmation de r√©servation'
          });
        }

        if (reservation.reminderSent && false) { // √âviter la duplication
          communications.push({
            id: `reservation-reminder-${reservation.id}`,
            type: 'email',
            content: `Email de rappel pour votre rendez-vous ${reservation.services}`,
            timestamp: new Date(reservation.date.getTime() - 48 * 60 * 60 * 1000), // 48h avant
            status: 'sent',
            templateUsed: 'Rappel de rendez-vous'
          });
        }
      });
    } catch (error) {
      console.log('Erreur lors de la r√©cup√©ration des r√©servations:', error);
    }

    // Trier par date d√©croissante
    communications.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

    // Retourner les 30 derni√®res communications
    const recentCommunications = communications.slice(0, 30);

    return NextResponse.json(recentCommunications);

  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration de l\'historique:', error);
    
    // Retourner des donn√©es mock√©es en cas d'erreur
    const mockData: CommunicationHistory[] = [
      {
        id: '1',
        type: 'whatsapp',
        content: 'Bonjour, votre rendez-vous pour Soin visage anti-√¢ge est confirm√© le 25/03/2024 √† 14:00 chez ${siteName}. √Ä bient√¥t ! ‚ú®',
        timestamp: new Date('2024-03-24T10:00:00'),
        status: 'delivered',
        templateUsed: 'Confirmation de rendez-vous'
      },
      {
        id: '2',
        type: 'email',
        content: 'Merci pour votre visite ! Nous esp√©rons que vous avez appr√©ci√© votre soin. N\'h√©sitez pas √† nous faire part de vos commentaires.',
        timestamp: new Date('2024-03-25T16:30:00'),
        status: 'read',
        templateUsed: 'Suivi apr√®s soin',
        subject: 'Merci pour votre visite chez ${siteName}'
      },
      {
        id: '3',
        type: 'whatsapp',
        content: 'Rappel : Votre rdv Soin hydratant est demain 28/03/2024 √† 15:30. Nous avons h√¢te de vous accueillir chez ${siteName} ! üí´',
        timestamp: new Date('2024-03-27T09:00:00'),
        status: 'read',
        templateUsed: 'Rappel de rendez-vous'
      },
      {
        id: '4',
        type: 'email',
        content: 'Email de confirmation de votre r√©servation pour Soin hydratant le 28/03/2024 √† 15:30.',
        timestamp: new Date('2024-03-20T14:15:00'),
        status: 'sent',
        templateUsed: 'Confirmation de r√©servation',
        subject: 'Confirmation de votre rendez-vous ${siteName}'
      }
    ];

    return NextResponse.json(mockData);
  }
}

// Endpoint pour enregistrer une nouvelle communication
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const prisma = await getPrismaClient();
  try {
    const { id } = await params;

    // V√©rifier l'authentification
    const authHeader = request.headers.get('authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Non autoris√©' }, { status: 401 });
    }

    const token = authHeader.substring(7);

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
      if (decoded.role !== 'admin' && !isAdminRole(decoded.role)) {
        return NextResponse.json({ error: 'Acc√®s interdit' }, { status: 403 });
      }
    } catch (error) {
      return NextResponse.json({ error: 'Token invalide' }, { status: 401 });
    }

    const { type, content, templateUsed, subject, status = 'sent' } = await request.json();
    const clientId = id;

    if (type === 'whatsapp') {
      // Enregistrer dans l'historique WhatsApp
      try {
        const whatsappRecord = await prisma.whatsAppHistory?.create({
          data: {
            userId: clientId,
            from: 'system',
            to: clientId,
            message: content,
            status,
            createdAt: new Date()
          }
        });
        
        return NextResponse.json({ 
          success: true, 
          id: whatsappRecord?.id || Date.now().toString()
        });
      } catch (error) {
        console.log('Table whatsAppHistory non trouv√©e, simulation d\'enregistrement');
        return NextResponse.json({ 
          success: true, 
          id: Date.now().toString(),
          note: 'Enregistr√© localement (table non disponible)'
        });
      }
    } else if (type === 'email') {
      // Enregistrer dans l'historique des emails
      try {
        const emailRecord = await prisma.emailHistory?.create({
          data: {
            userId: clientId,
            to: clientId,
            content,
            subject,
            template: templateUsed,
            status,
            createdAt: new Date()
          }
        });
        
        return NextResponse.json({ 
          success: true, 
          id: emailRecord?.id || Date.now().toString()
        });
      } catch (error) {
        console.log('Table emailHistory non trouv√©e, simulation d\'enregistrement');
        return NextResponse.json({ 
          success: true, 
          id: Date.now().toString(),
          note: 'Enregistr√© localement (table non disponible)'
        });
      }
    }

    return NextResponse.json({ error: 'Type de communication non support√©' }, { status: 400 });

  } catch (error) {
    console.error('Erreur lors de l\'enregistrement:', error);
    return NextResponse.json({ 
      error: 'Erreur lors de l\'enregistrement',
      details: error instanceof Error ? error.message : 'Erreur inconnue'
    }, { status: 500 });
  }
}
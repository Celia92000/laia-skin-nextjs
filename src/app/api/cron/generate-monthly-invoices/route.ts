import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { generateAndSaveInvoice } from '@/lib/invoice-service'

const PLAN_PRICES = {
  SOLO: 49,
  DUO: 99,
  TEAM: 199,
  PREMIUM: 399
}

/**
 * Cron job pour g√©n√©rer les factures mensuelles automatiquement
 * √Ä ex√©cuter le 1er de chaque mois
 * URL: /api/cron/generate-monthly-invoices
 *
 * Configuration Vercel Cron (vercel.json):
 * {
 *   "crons": [{
 *     "path": "/api/cron/generate-monthly-invoices",
 *     "schedule": "0 0 1 * *"
 *   }]
 * }
 */
export async function GET(request: NextRequest) {
  try {
    // V√©rifier l'authentification du cron (Vercel envoie un header Authorization)
    const authHeader = request.headers.get('authorization')
    const cronSecret = process.env.CRON_SECRET

    if (cronSecret && authHeader !== `Bearer ${cronSecret}`) {
      return NextResponse.json({ error: 'Non autoris√©' }, { status: 401 })
    }

    console.log('üîÑ D√©marrage g√©n√©ration factures mensuelles...')

    // R√©cup√©rer toutes les organisations ACTIVE
    const organizations = await prisma.organization.findMany({
      where: {
        status: 'ACTIVE',
        plan: { in: ['SOLO', 'DUO', 'TEAM', 'PREMIUM'] }
      },
      select: {
        id: true,
        name: true,
        plan: true,
        subscriptionStartDate: true
      }
    })

    console.log(`üìä ${organizations.length} organisations actives trouv√©es`)

    const results = {
      success: [] as string[],
      errors: [] as { org: string, error: string }[],
      skipped: [] as string[]
    }

    const now = new Date()
    const currentMonth = now.getMonth()
    const currentYear = now.getFullYear()

    for (const org of organizations) {
      try {
        // V√©rifier si une facture existe d√©j√† pour ce mois
        const existingInvoice = await prisma.invoice.findFirst({
          where: {
            organizationId: org.id,
            issueDate: {
              gte: new Date(currentYear, currentMonth, 1),
              lt: new Date(currentYear, currentMonth + 1, 1)
            }
          }
        })

        if (existingInvoice) {
          console.log(`‚è≠Ô∏è  Facture d√©j√† existante pour ${org.name}`)
          results.skipped.push(org.name)
          continue
        }

        // V√©rifier que l'organisation a d√©pass√© la p√©riode d'essai
        if (org.subscriptionStartDate) {
          const subscriptionStart = new Date(org.subscriptionStartDate)
          if (subscriptionStart > now) {
            console.log(`‚è≠Ô∏è  ${org.name} - Abonnement pas encore d√©marr√©`)
            results.skipped.push(org.name)
            continue
          }
        }

        // R√©cup√©rer le prix du plan
        const amount = PLAN_PRICES[org.plan as keyof typeof PLAN_PRICES]

        if (!amount) {
          console.log(`‚ö†Ô∏è  Plan inconnu pour ${org.name}: ${org.plan}`)
          results.errors.push({ org: org.name, error: 'Plan inconnu' })
          continue
        }

        // G√©n√©rer la facture
        console.log(`üí∞ G√©n√©ration facture pour ${org.name} - ${org.plan} (${amount}‚Ç¨)`)

        await generateAndSaveInvoice(
          org.id,
          amount,
          org.plan,
          undefined // Pas de Stripe payment intent pour facture automatique
        )

        results.success.push(org.name)
        console.log(`‚úÖ Facture cr√©√©e pour ${org.name}`)

      } catch (error) {
        console.error(`‚ùå Erreur pour ${org.name}:`, error)
        results.errors.push({
          org: org.name,
          error: error instanceof Error ? error.message : 'Erreur inconnue'
        })
      }
    }

    // Envoyer notification aux admins si des erreurs
    if (results.errors.length > 0) {
      console.warn('‚ö†Ô∏è  Erreurs d√©tect√©es lors de la g√©n√©ration:', results.errors)

      // TODO: Envoyer email de notification au super-admin
      // await sendAdminNotification({
      //   subject: 'Erreurs g√©n√©ration factures mensuelles',
      //   errors: results.errors
      // })
    }

    console.log('‚úÖ G√©n√©ration factures termin√©e')
    console.log(`   - R√©ussies: ${results.success.length}`)
    console.log(`   - Ignor√©es: ${results.skipped.length}`)
    console.log(`   - Erreurs: ${results.errors.length}`)

    // Logger l'activit√©
    await prisma.activityLog.create({
      data: {
        userId: 'system',
        action: 'MONTHLY_INVOICES_GENERATED',
        entityType: 'INVOICE',
        entityId: 'cron',
        description: `G√©n√©ration automatique des factures mensuelles`,
        metadata: {
          total: organizations.length,
          success: results.success.length,
          skipped: results.skipped.length,
          errors: results.errors.length,
          date: now.toISOString()
        }
      }
    })

    return NextResponse.json({
      success: true,
      message: 'Factures g√©n√©r√©es avec succ√®s',
      stats: {
        total: organizations.length,
        success: results.success.length,
        skipped: results.skipped.length,
        errors: results.errors.length
      },
      details: results
    })

  } catch (error) {
    console.error('‚ùå Erreur critique g√©n√©ration factures:', error)
    return NextResponse.json(
      {
        success: false,
        error: 'Erreur serveur',
        message: error instanceof Error ? error.message : 'Erreur inconnue'
      },
      { status: 500 }
    )
  }
}

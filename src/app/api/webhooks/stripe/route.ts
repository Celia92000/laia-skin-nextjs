import { NextRequest, NextResponse } from 'next/server'
import { stripe } from '@/lib/stripe-service'
import { prisma } from '@/lib/prisma'
import Stripe from 'stripe'

/**
 * Webhook Stripe pour g√©rer les √©v√©nements de paiement
 *
 * Configure ce webhook dans ton dashboard Stripe :
 * URL : https://votre-domaine.com/api/webhooks/stripe
 * √âv√©nements √† √©couter :
 * - payment_intent.succeeded
 * - payment_intent.payment_failed
 * - customer.subscription.updated
 * - customer.subscription.deleted
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.text()
    const signature = request.headers.get('stripe-signature')

    if (!signature) {
      return NextResponse.json(
        { error: 'Signature manquante' },
        { status: 400 }
      )
    }

    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET

    if (!webhookSecret) {
      console.error('STRIPE_WEBHOOK_SECRET non configur√©')
      return NextResponse.json(
        { error: 'Configuration manquante' },
        { status: 500 }
      )
    }

    // V√©rifier la signature du webhook
    let event: Stripe.Event

    try {
      event = stripe.webhooks.constructEvent(body, signature, webhookSecret)
    } catch (err) {
      console.error('‚ùå Signature webhook invalide:', err)
      return NextResponse.json(
        { error: 'Signature invalide' },
        { status: 400 }
      )
    }

    console.log(`üì® Webhook re√ßu: ${event.type}`)

    // G√©rer les diff√©rents √©v√©nements
    switch (event.type) {
      case 'payment_intent.succeeded': {
        const paymentIntent = event.data.object as Stripe.PaymentIntent
        await handlePaymentSuccess(paymentIntent)
        break
      }

      case 'payment_intent.payment_failed': {
        const paymentIntent = event.data.object as Stripe.PaymentIntent
        await handlePaymentFailed(paymentIntent)
        break
      }

      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription
        await handleSubscriptionUpdated(subscription)
        break
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription
        await handleSubscriptionDeleted(subscription)
        break
      }

      default:
        console.log(`‚ö†Ô∏è √âv√©nement non g√©r√©: ${event.type}`)
    }

    return NextResponse.json({ received: true })
  } catch (error) {
    console.error('‚ùå Erreur webhook Stripe:', error)
    return NextResponse.json(
      { error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}

/**
 * G√®re le succ√®s d'un paiement
 */
async function handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent) {
  const organizationId = paymentIntent.metadata.organizationId

  if (!organizationId) {
    console.warn('‚ö†Ô∏è organizationId manquant dans les metadata')
    return
  }

  try {
    // Mettre √† jour l'organisation
    await prisma.organization.update({
      where: { id: organizationId },
      data: {
        status: 'ACTIVE',
        lastPaymentDate: new Date(),
      },
    })

    console.log(`‚úÖ Paiement r√©ussi pour l'organisation ${organizationId}`)

    // TODO: Envoyer email de confirmation
    // TODO: G√©n√©rer facture PDF
  } catch (error) {
    console.error('Erreur mise √† jour apr√®s paiement:', error)
  }
}

/**
 * G√®re l'√©chec d'un paiement
 */
async function handlePaymentFailed(paymentIntent: Stripe.PaymentIntent) {
  const organizationId = paymentIntent.metadata.organizationId

  if (!organizationId) {
    console.warn('‚ö†Ô∏è organizationId manquant dans les metadata')
    return
  }

  try {
    // Suspendre l'organisation
    await prisma.organization.update({
      where: { id: organizationId },
      data: {
        status: 'SUSPENDED',
      },
    })

    console.log(`‚ùå Paiement √©chou√© pour l'organisation ${organizationId}`)

    // TODO: Envoyer email d'√©chec
    // TODO: Cr√©er notification super admin
  } catch (error) {
    console.error('Erreur mise √† jour apr√®s √©chec paiement:', error)
  }
}

/**
 * G√®re la mise √† jour d'un abonnement
 */
async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  const customerId = subscription.customer as string

  try {
    const org = await prisma.organization.findFirst({
      where: { stripeCustomerId: customerId },
    })

    if (!org) {
      console.warn(`‚ö†Ô∏è Organisation introuvable pour customer ${customerId}`)
      return
    }

    console.log(`üîÑ Abonnement mis √† jour pour ${org.name}`)

    // TODO: Synchroniser les changements d'abonnement
  } catch (error) {
    console.error('Erreur mise √† jour abonnement:', error)
  }
}

/**
 * G√®re la suppression d'un abonnement
 */
async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  const customerId = subscription.customer as string

  try {
    const org = await prisma.organization.findFirst({
      where: { stripeCustomerId: customerId },
    })

    if (!org) {
      console.warn(`‚ö†Ô∏è Organisation introuvable pour customer ${customerId}`)
      return
    }

    // Annuler l'organisation
    await prisma.organization.update({
      where: { id: org.id },
      data: {
        status: 'CANCELLED',
      },
    })

    console.log(`üóëÔ∏è Abonnement annul√© pour ${org.name}`)

    // TODO: Envoyer email de confirmation d'annulation
  } catch (error) {
    console.error('Erreur suppression abonnement:', error)
  }
}

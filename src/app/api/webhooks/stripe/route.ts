import { NextRequest, NextResponse } from 'next/server'
import { stripe } from '@/lib/stripe-service'
import { prisma } from '@/lib/prisma'
import { generateAndSaveInvoice } from '@/lib/invoice-service'
import { sendPaymentSuccessEmail, sendPaymentFailedEmail } from '@/lib/payment-emails'
import Stripe from 'stripe'

/**
 * Webhook Stripe pour g√©rer les √©v√©nements de paiement
 *
 * Configure ce webhook dans ton dashboard Stripe :
 * URL : https://votre-domaine.com/api/webhooks/stripe
 * √âv√©nements √† √©couter :
 * - payment_intent.succeeded
 * - payment_intent.payment_failed
 * - customer.subscription.updated
 * - customer.subscription.deleted
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.text()
    const signature = request.headers.get('stripe-signature')

    if (!signature) {
      return NextResponse.json(
        { error: 'Signature manquante' },
        { status: 400 }
      )
    }

    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET

    if (!webhookSecret) {
      console.error('STRIPE_WEBHOOK_SECRET non configur√©')
      return NextResponse.json(
        { error: 'Configuration manquante' },
        { status: 500 }
      )
    }

    // V√©rifier la signature du webhook
    let event: Stripe.Event

    try {
      event = stripe.webhooks.constructEvent(body, signature, webhookSecret)
    } catch (err) {
      console.error('‚ùå Signature webhook invalide:', err)
      return NextResponse.json(
        { error: 'Signature invalide' },
        { status: 400 }
      )
    }

    console.log(`üì® Webhook re√ßu: ${event.type}`)

    // G√©rer les diff√©rents √©v√©nements
    switch (event.type) {
      case 'payment_intent.succeeded': {
        const paymentIntent = event.data.object as Stripe.PaymentIntent
        await handlePaymentSuccess(paymentIntent)
        break
      }

      case 'payment_intent.payment_failed': {
        const paymentIntent = event.data.object as Stripe.PaymentIntent
        await handlePaymentFailed(paymentIntent)
        break
      }

      case 'customer.subscription.updated': {
        const subscription = event.data.object as Stripe.Subscription
        await handleSubscriptionUpdated(subscription)
        break
      }

      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription
        await handleSubscriptionDeleted(subscription)
        break
      }

      default:
        console.log(`‚ö†Ô∏è √âv√©nement non g√©r√©: ${event.type}`)
    }

    return NextResponse.json({ received: true })
  } catch (error) {
    console.error('‚ùå Erreur webhook Stripe:', error)
    return NextResponse.json(
      { error: 'Erreur serveur' },
      { status: 500 }
    )
  }
}

/**
 * G√®re le succ√®s d'un paiement
 */
async function handlePaymentSuccess(paymentIntent: Stripe.PaymentIntent) {
  const organizationId = paymentIntent.metadata.organizationId

  if (!organizationId) {
    console.warn('‚ö†Ô∏è organizationId manquant dans les metadata')
    return
  }

  try {
    // R√©cup√©rer l'organisation
    const org = await prisma.organization.findUnique({
      where: { id: organizationId },
    })

    if (!org) {
      console.warn(`‚ö†Ô∏è Organisation ${organizationId} introuvable`)
      return
    }

    // Mettre √† jour l'organisation
    await prisma.organization.update({
      where: { id: organizationId },
      data: {
        status: 'ACTIVE',
        lastPaymentDate: new Date(),
      },
    })

    console.log(`‚úÖ Paiement r√©ussi pour l'organisation ${organizationId}`)

    // Calculer la prochaine date de facturation
    const nextBillingDate = new Date(org.nextBillingDate || new Date())
    nextBillingDate.setMonth(nextBillingDate.getMonth() + 1)

    // G√©n√©rer la facture PDF
    const planPrices: Record<string, number> = {
      SOLO: 49,
      DUO: 89,
      TEAM: 149,
      PREMIUM: 249,
    }
    const amount = planPrices[org.plan] || 0

    try {
      const invoice = await generateAndSaveInvoice(
        org.id,
        amount,
        org.plan,
        paymentIntent.id
      )

      console.log(`üìÑ Facture g√©n√©r√©e: ${invoice.invoiceNumber}`)

      // Envoyer l'email de confirmation avec la facture
      await sendPaymentSuccessEmail({
        to: org.billingEmail || org.ownerEmail,
        organizationName: org.name,
        amount,
        plan: org.plan,
        nextBillingDate,
        invoiceUrl: invoice.pdfUrl,
      })

      console.log(`üìß Email de confirmation envoy√©`)
    } catch (emailError) {
      console.error('‚ö†Ô∏è Erreur envoi email/facture (non bloquant):', emailError)
    }
  } catch (error) {
    console.error('Erreur mise √† jour apr√®s paiement:', error)
  }
}

/**
 * G√®re l'√©chec d'un paiement
 */
async function handlePaymentFailed(paymentIntent: Stripe.PaymentIntent) {
  const organizationId = paymentIntent.metadata.organizationId

  if (!organizationId) {
    console.warn('‚ö†Ô∏è organizationId manquant dans les metadata')
    return
  }

  try {
    // R√©cup√©rer l'organisation
    const org = await prisma.organization.findUnique({
      where: { id: organizationId },
    })

    if (!org) {
      console.warn(`‚ö†Ô∏è Organisation ${organizationId} introuvable`)
      return
    }

    // Suspendre l'organisation
    await prisma.organization.update({
      where: { id: organizationId },
      data: {
        status: 'SUSPENDED',
      },
    })

    console.log(`‚ùå Paiement √©chou√© pour l'organisation ${organizationId}`)

    // Calculer le montant
    const planPrices: Record<string, number> = {
      SOLO: 49,
      DUO: 89,
      TEAM: 149,
      PREMIUM: 249,
    }
    const amount = planPrices[org.plan] || 0

    // Envoyer email d'√©chec
    try {
      await sendPaymentFailedEmail({
        to: org.billingEmail || org.ownerEmail,
        organizationName: org.name,
        amount,
        plan: org.plan,
        reason: paymentIntent.last_payment_error?.message,
      })

      console.log(`üìß Email d'√©chec envoy√©`)
    } catch (emailError) {
      console.error('‚ö†Ô∏è Erreur envoi email √©chec (non bloquant):', emailError)
    }

    // TODO: Cr√©er notification super admin
  } catch (error) {
    console.error('Erreur mise √† jour apr√®s √©chec paiement:', error)
  }
}

/**
 * G√®re la mise √† jour d'un abonnement
 */
async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  const customerId = subscription.customer as string

  try {
    const org = await prisma.organization.findFirst({
      where: { stripeCustomerId: customerId },
    })

    if (!org) {
      console.warn(`‚ö†Ô∏è Organisation introuvable pour customer ${customerId}`)
      return
    }

    console.log(`üîÑ Abonnement mis √† jour pour ${org.name}`)

    // TODO: Synchroniser les changements d'abonnement
  } catch (error) {
    console.error('Erreur mise √† jour abonnement:', error)
  }
}

/**
 * G√®re la suppression d'un abonnement
 */
async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  const customerId = subscription.customer as string

  try {
    const org = await prisma.organization.findFirst({
      where: { stripeCustomerId: customerId },
    })

    if (!org) {
      console.warn(`‚ö†Ô∏è Organisation introuvable pour customer ${customerId}`)
      return
    }

    // Annuler l'organisation
    await prisma.organization.update({
      where: { id: org.id },
      data: {
        status: 'CANCELLED',
      },
    })

    console.log(`üóëÔ∏è Abonnement annul√© pour ${org.name}`)

    // TODO: Envoyer email de confirmation d'annulation
  } catch (error) {
    console.error('Erreur suppression abonnement:', error)
  }
}

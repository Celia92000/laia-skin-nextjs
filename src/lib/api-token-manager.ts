/**
 * Gestionnaire s√©curis√© des tokens API
 * Chiffre/d√©chiffre et stocke les tokens de mani√®re s√©curis√©e
 */

import { PrismaClient } from '@prisma/client';
import { encrypt, decrypt } from './encryption-service';

const prisma = new PrismaClient();

export interface ApiToken {
  id?: string;
  service: 'WHATSAPP' | 'INSTAGRAM' | 'FACEBOOK' | 'STRIPE' | 'RESEND' | 'OTHER';
  name: string;
  tokenEncrypted: string;
  expiresAt?: Date | null;
  organizationId?: string | null;
  metadata?: any;
  createdAt?: Date;
  updatedAt?: Date;
}

/**
 * Stocke un token API de mani√®re chiffr√©e
 */
export async function storeApiToken(params: {
  service: ApiToken['service'];
  name: string;
  token: string;
  expiresAt?: Date;
  organizationId?: string;
  metadata?: any;
}): Promise<ApiToken> {
  // Chiffrer le token
  const tokenEncrypted = encrypt(params.token);

  // V√©rifier si un token existe d√©j√† pour ce service/nom/org
  const existing = await prisma.apiToken.findFirst({
    where: {
      service: params.service,
      name: params.name,
      organizationId: params.organizationId || null,
    },
  });

  if (existing) {
    // Mettre √† jour
    const updated = await prisma.apiToken.update({
      where: { id: existing.id },
      data: {
        tokenEncrypted,
        expiresAt: params.expiresAt,
        metadata: params.metadata,
      },
    });

    console.log(`‚úÖ Token ${params.service}:${params.name} mis √† jour`);
    return updated;
  } else {
    // Cr√©er
    const created = await prisma.apiToken.create({
      data: {
        service: params.service,
        name: params.name,
        tokenEncrypted,
        expiresAt: params.expiresAt,
        organizationId: params.organizationId,
        metadata: params.metadata,
      },
    });

    console.log(`‚úÖ Token ${params.service}:${params.name} cr√©√©`);
    return created;
  }
}

/**
 * R√©cup√®re un token API d√©chiffr√©
 */
export async function getApiToken(params: {
  service: ApiToken['service'];
  name: string;
  organizationId?: string;
}): Promise<string | null> {
  const token = await prisma.apiToken.findFirst({
    where: {
      service: params.service,
      name: params.name,
      organizationId: params.organizationId || null,
    },
  });

  if (!token) {
    console.warn(`‚ö†Ô∏è  Token ${params.service}:${params.name} introuvable`);
    return null;
  }

  // V√©rifier l'expiration
  if (token.expiresAt && token.expiresAt < new Date()) {
    console.warn(`‚ö†Ô∏è  Token ${params.service}:${params.name} EXPIR√â`);
    return null;
  }

  // D√©chiffrer et retourner
  try {
    return decrypt(token.tokenEncrypted);
  } catch (error) {
    console.error(`‚ùå Erreur d√©chiffrement token ${params.service}:${params.name}:`, error);
    return null;
  }
}

/**
 * Liste tous les tokens (sans les d√©chiffrer)
 */
export async function listApiTokens(organizationId?: string): Promise<ApiToken[]> {
  return await prisma.apiToken.findMany({
    where: organizationId ? { organizationId } : {},
    orderBy: { createdAt: 'desc' },
  });
}

/**
 * Supprime un token
 */
export async function deleteApiToken(tokenId: string): Promise<boolean> {
  try {
    await prisma.apiToken.delete({
      where: { id: tokenId },
    });
    console.log(`‚úÖ Token ${tokenId} supprim√©`);
    return true;
  } catch (error) {
    console.error(`‚ùå Erreur suppression token ${tokenId}:`, error);
    return false;
  }
}

/**
 * V√©rifie les tokens qui vont expirer bient√¥t
 */
export async function checkExpiringTokens(daysBeforeExpiration: number = 7): Promise<ApiToken[]> {
  const futureDate = new Date();
  futureDate.setDate(futureDate.getDate() + daysBeforeExpiration);

  const expiringTokens = await prisma.apiToken.findMany({
    where: {
      expiresAt: {
        gte: new Date(),
        lte: futureDate,
      },
    },
    orderBy: { expiresAt: 'asc' },
  });

  if (expiringTokens.length > 0) {
    console.warn(`‚ö†Ô∏è  ${expiringTokens.length} token(s) expirent dans les ${daysBeforeExpiration} prochains jours`);
    expiringTokens.forEach(token => {
      const daysLeft = Math.ceil(
        (token.expiresAt!.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)
      );
      console.warn(`   - ${token.service}:${token.name} expire dans ${daysLeft} jours`);
    });
  }

  return expiringTokens;
}

/**
 * Migre les tokens depuis .env vers la base de donn√©es
 */
export async function migrateTokensFromEnv(): Promise<void> {
  console.log('üîÑ Migration des tokens depuis .env...\n');

  const migrations = [
    {
      service: 'WHATSAPP' as const,
      name: 'access_token',
      token: process.env.WHATSAPP_ACCESS_TOKEN,
      expiresAt: new Date('2025-12-15'), // √Ä calculer selon vos tokens
    },
    {
      service: 'INSTAGRAM' as const,
      name: 'access_token',
      token: process.env.INSTAGRAM_ACCESS_TOKEN,
      expiresAt: new Date('2025-12-16'),
    },
    {
      service: 'FACEBOOK' as const,
      name: 'page_access_token',
      token: process.env.FACEBOOK_PAGE_ACCESS_TOKEN,
      expiresAt: new Date('2025-12-11'),
    },
    {
      service: 'STRIPE' as const,
      name: 'secret_key',
      token: process.env.STRIPE_SECRET_KEY,
      expiresAt: undefined, // Pas d'expiration
    },
    {
      service: 'RESEND' as const,
      name: 'api_key',
      token: process.env.RESEND_API_KEY,
      expiresAt: undefined,
    },
  ];

  for (const migration of migrations) {
    if (migration.token) {
      try {
        await storeApiToken(migration);
        console.log(`   ‚úÖ ${migration.service}:${migration.name}`);
      } catch (error) {
        console.error(`   ‚ùå ${migration.service}:${migration.name}:`, error);
      }
    } else {
      console.log(`   ‚ö†Ô∏è  ${migration.service}:${migration.name} manquant dans .env`);
    }
  }

  console.log('\n‚úÖ Migration termin√©e\n');
}

/**
 * Helper pour obtenir le token WhatsApp
 */
export async function getWhatsAppToken(organizationId?: string): Promise<string | null> {
  // D'abord chercher en base
  const dbToken = await getApiToken({
    service: 'WHATSAPP',
    name: 'access_token',
    organizationId,
  });

  // Fallback sur .env si pas en base
  return dbToken || process.env.WHATSAPP_ACCESS_TOKEN || null;
}

/**
 * Helper pour obtenir le token Instagram
 */
export async function getInstagramToken(organizationId?: string): Promise<string | null> {
  const dbToken = await getApiToken({
    service: 'INSTAGRAM',
    name: 'access_token',
    organizationId,
  });

  return dbToken || process.env.INSTAGRAM_ACCESS_TOKEN || null;
}

/**
 * Helper pour obtenir le token Facebook
 */
export async function getFacebookToken(organizationId?: string): Promise<string | null> {
  const dbToken = await getApiToken({
    service: 'FACEBOOK',
    name: 'page_access_token',
    organizationId,
  });

  return dbToken || process.env.FACEBOOK_PAGE_ACCESS_TOKEN || null;
}

/**
 * Helper pour obtenir la cl√© Stripe
 */
export async function getStripeKey(organizationId?: string): Promise<string | null> {
  const dbToken = await getApiToken({
    service: 'STRIPE',
    name: 'secret_key',
    organizationId,
  });

  return dbToken || process.env.STRIPE_SECRET_KEY || null;
}
